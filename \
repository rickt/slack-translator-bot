package slackdictionarybot

import (
	"bytes"
	"encoding/json"
	"fmt"
	// "github.com/davecgh/go-spew/spew"
	"google.golang.org/appengine"
	"google.golang.org/appengine/urlfetch"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// globals
var (
	env envVars
)

// helper function to do a case-insensitive search
func ciContains(a, b string) bool {
	return strings.Contains(strings.ToUpper(a), strings.ToUpper(b))
}

// helper func to read the api response body (an io.ReadCloser) and output it as simple string
func getBody(resp *http.Response) string {
	buf := new(bytes.Buffer)
	buf.ReadFrom(resp.Body)
	return buf.String()
}

// there's no main() func in google app engine
func init() {
	// get runtime options from the app.yaml
	env.APIBaseURL = os.Getenv("OXFORD_DICTIONARY_API_BASEURL")
	env.APPID = os.Getenv("OXFORD_DICTIONARY_APP_ID")
	env.APPKey = os.Getenv("OXFORD_DICTIONARY_APP_KEY")
	env.APIPath = os.Getenv("OXFORD_DICTIONARY_API_PATH")
	env.VerifyToken = os.Getenv("SLACK_VERIFY_TOKEN")
	// setup http handlers
	http.HandleFunc("/", handler_redirect)
	http.HandleFunc("/lookup", handler_lookup)
}

// redirect root requests to /lookup
func handler_redirect(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, "/lookup", 302)
}

func handler_lookup(w http.ResponseWriter, r *http.Request) {
	// vars
	var word string
	var apiurl *url.URL
	// create a google app engine context
	ctx := appengine.NewContext(r)
	// what is our OG query from slack?
	err := r.ParseForm()
	if err != nil {
		fmt.Fprintf(w, "\n\nError parsing form, err=%s, rsp.Body= %s", err.Error(), r.Body)
		return
	}
	defer r.Body.Close()
	// what is the word to lookup?
	word = r.URL.Query().Get("word")
	fmt.Fprintf(w, "\n\nWord to lookup: %s\n\n", word)
	// build the url! an example call to the Oxford Dictionary API:
	// https://od-api.oxforddictionaries.com:443/api/v1/entries/en/<word>
	apiurl, _ = url.Parse(env.APIBaseURL)
	apiurl.Path += env.APIPath
	apiurl.Path += "/"
	apiurl.Path += word
	// build the JSON we will send along with the request
	jr := OxfordRequest {
		Type:		"application/json",
		App_ID:		env.APPID,
		App_Key:	env.APPKey,

	}
	var jr2 = `
	{"Name": "Accept", "Text": "application/json"}
	{"Name": "app_id", "Text": env.APPID}
	{"Name": "app_key", "Text": env.APPKey}`

	// create an http.Client and make the call to the Google Translate API
	req, _ := http.NewRequest("POST", apiurl.String(), json.NewDecoder(strings.NewReader(jr)))
	client := urlfetch.Client(ctx)
	response, _ := client.Do(req)
	// decode the API response
	jstr := getBody(response)
	// unmarshal the JSON string into a nice struct
	var jsonresponse OxfordReply
	err = json.Unmarshal(jstr, &jsonresponse)
	if err != nil {
		fmt.Fprintf(w, "\n\nError unmarshalling JSON, err=%s, response.Body= %s", err.Error(), r.Body)
		return
	}
	// print out the "from"
	fmt.Fprintf(w, "*Oxford Dictionary definition of* \"%s\":\n", word)
	fmt.Fprintf(w, "%v\n", jsonresponse)
	// print out the "to"
	// for _, z := range jsonresponse.Data.Translations {
		// fmt.Fprintf(w, "*Translated* %s = %s\n\n", emoji_to, z.TranslatedText)
	// }
	return
}
